/**
 ******************************************************************************
 * @addtogroup OpenPilotModules OpenPilot Modules
 * @{
 * @addtogroup Sensors
 * @brief Acquires sensor data
 * @{
 *
 * @file       sensors.c
 * @author     The OpenPilot Team, http://www.openpilot.org Copyright (C) 2015.
 * @brief      Module to handle fetch and preprocessing of sensor data
 *
 * @see        The GNU Public License (GPL) Version 3
 *
 ******************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/**
 * Input objects: None, takes sensor data via pios
 * Output objects: @ref GyroSensor @ref AccelSensor @ref MagSensor
 *
 * The module executes in its own thread.
 *
 * UAVObjects are automatically generated by the UAVObjectGenerator from
 * the object definition XML file.
 *
 * Modules have no API, all communication to other modules is done through UAVObjects.
 * However modules may use the API exposed by shared libraries.
 * See the OpenPilot wiki for more details.
 * http://www.openpilot.org/OpenPilot_Application_Architecture
 *
 */

#include <openpilot.h>
#include <luasettings.h>
#include <taskinfo.h>
#include <string.h>
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

// Private constants
#define STACK_SIZE_BYTES    4000
#define TASK_PRIORITY       (tskIDLE_PRIORITY + 3)
#define BUFFER_SIZE_MAX     1024


#define LUA_LOG_FILE_FLAG (PIOS_FS_CREAT | PIOS_FS_WRONLY | PIOS_FS_APPEND)
#define LUA_LOG_FILE_NAME "lua_error.log"

// Lua will search for this function in the script and execture it.
#define LUA_START_FUNCTION_NAME "op_start"

// Define the following to debug (it will stop on C/lua interface error)
#define LUA_ASSERT(test) {if (!(test)) while(1);}

// File system that holds the scripts.
extern uintptr_t pios_flashfs_id;

// Resting delay.
static const TickType_t lua_period_ticks = (1000 * portTICK_RATE_MS);

// Private functions
static void LuaTask(void *parameters);

// Private variables
static xTaskHandle luaTaskHandle;


/**
 * Initialise the module.  Called before the start function
 * \returns 0 on success or -1 if initialisation failed
 */
int32_t LuaInitialize(void) {
    LuasettingsInitialize();
    return 0;
}


/**
 * Start the task.  Expects all objects to be initialized by this point.
 * \returns 0 on success or -1 if initialisation failed
 */
int32_t LuaStart(void) {
    // Start main task
    xTaskCreate(LuaTask, "Lua", STACK_SIZE_BYTES / 4, NULL, TASK_PRIORITY, &luaTaskHandle);
    PIOS_TASK_MONITOR_RegisterTask(TASKINFO_RUNNING_LUA, luaTaskHandle);
    return 0;
}
MODULE_INITCALL(LuaInitialize, LuaStart);


static uint32_t bail(lua_State *L, char *msg){
    char opstderr[256];
    int16_t fh;

    sprintf(opstderr, "ERROR: %s: %s\n", msg, lua_tostring(L, -1));
    LUA_ASSERT(0);

    /* Log the error */
    /* TODO: make device and file name configurable */
    fh = PIOS_FS_Open(pios_flashfs_id, LUA_LOG_FILE_NAME, LUA_LOG_FILE_FLAG);
    if (fh >=0)
        PIOS_FS_Write(pios_flashfs_id, fh, (uint8_t*)opstderr, sizeof(opstderr));
    PIOS_FS_Close(pios_flashfs_id, fh);

    LUA_ASSERT(0);

    return -1;
}


static uint32_t luaScriptRun(char *filename) {

    uint32_t rc = 0;
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

#if 1

    if (!rc && luaL_loadfile(L, filename))
        rc = bail(L, "Error loading script");

    if (!rc && lua_pcall(L, 0, 0, 0))
        rc = bail(L, "lua_pcall() failed");

    if (!rc)
        lua_getglobal(L, LUA_START_FUNCTION_NAME);

    if (!rc && lua_pcall(L, 0, 0, 0))
        rc = bail(L, "Error calling script");

#else

    double z;
    if (!rc && luaL_dofile(L, filename))
        rc = bail(L, "Error loading script");

    lua_getglobal(L, LUA_START_FUNCTION_NAME);

    if (!rc && lua_pcall(L, 0, 1, 0) != 0)
        rc = bail(L, "Error calling script");

    if (!rc && !lua_isnumber(L, -1))
        rc = bail(L, "Incorrect return value");

    if (!rc){
        z = lua_tonumber(L, -1);
    lua_pop(L, 1);

    /* grab the error/return value from the script */
    rc = (uint32_t)z;
#endif

    lua_close(L);

    return rc;
}


static void LuaTask(__attribute__((unused)) void *parameters) {

    LuasettingsData LuaSettings;
    portTickType lastSysTime;
    bool execute;
    int status;

    // Main task loop
    lastSysTime = xTaskGetTickCount();

    while (1) {

        execute = false;

        // TODO: process all the instance (currently only one supported (singleinstance set to TRUE in object)
        LuasettingsGet(&LuaSettings);

        // Check if the script name is valid
        // TODO: add better check like extension ".lua" should be present.
        if (LuaSettings.Script[0] == 0) {
            // Update status
            LuaSettings.Status = LUASETTINGS_STATUS_ERROR;
            LuasettingsSet(&LuaSettings);
            vTaskDelayUntil(&lastSysTime, lua_period_ticks);
            continue;
        }

        // Check for triggers
        if (LuaSettings.Trigger) {
            // TODO: No trigger supported right now.
            // Potential future triggers:
            // - ARMED: when user arm the controller, the script would start/stop.
            // - DISARMED: when the user disarm the controller, the script would start/stop.
            // - GCSCONNECTED: when the board is connected to GCS, the script could start/stop.
            // - INPUT: when gpio pin # X is set high, the script would start/stop/
        }

        // Process the command
        switch (LuaSettings.Command) {
            case LUASETTINGS_COMMAND_ONCE:
                // The script will only run ONCE. Mostly useful when TRIGGERS are enabled
                // or as a startup script.
                if (LuaSettings.Iteration == 1) {
                    // Stop the script
                    LuaSettings.Command = LUASETTINGS_COMMAND_STOP;
                    LuaSettings.Status = LUASETTINGS_STATUS_STOPPED;
                }
                else {
                    LuaSettings.Iteration++;
                    execute = true;
                }
                break;
            case LUASETTINGS_COMMAND_STOP:
                // The script was on REPEAT and now need to be taken out of the loop.
                // A script already stopped will stay in the STOP state.
                LuaSettings.Status = LUASETTINGS_STATUS_STOPPED;
                LuaSettings.Iteration = 0;
                break;
            case LUASETTINGS_COMMAND_LOOP:
                // Re-run the script that has STOPPED or that meant to run in a loop.
                LuaSettings.Iteration++;
                execute = true;
                break;
            default:
                break;
        }

        if (execute) {
            LuaSettings.Status = LUASETTINGS_STATUS_RUNNING;
            //LuasettingsSet(&LuaSettings);
            status = 0;

            if (!status)
                status = luaScriptRun((char*)LuaSettings.Script);

            if (status)
                LuaSettings.Status = LUASETTINGS_STATUS_ERROR;
            else
                LuaSettings.Status = LUASETTINGS_STATUS_FINISHED;
        }

        LuasettingsSet(&LuaSettings);

        // TODO: Get next instance.
        // Once all the instance had the chance to run, then restart from the first instance.
        // TODO: There is no priority at this point.

        // Let give it some rest before starting the next scripts?
        vTaskDelayUntil(&lastSysTime, lua_period_ticks);
    }
}


/**
 * @}
 * @}
 */
