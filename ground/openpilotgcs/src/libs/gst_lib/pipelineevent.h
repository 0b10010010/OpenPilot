/*
 * PipelineEvent.h
 *
 *  Created on: 8 déc. 2012
 *      Author: Utilisateur
 */

#ifndef PIPELINEEVENT_H_
#define PIPELINEEVENT_H_

#include <QEvent>
#include <QString>

#include "pipeline.h"
#include "overlay.h"

class PipelineEvent: public QEvent {
public:
	// event types
	static const QEvent::Type PrepareWindowId;
	static const QEvent::Type StateChange;
	static const QEvent::Type Qos;
	static const QEvent::Type Error;

	PipelineEvent(QEvent::Type type, QString src) :
			QEvent(type), src(src) {
	}
	virtual ~PipelineEvent() {
	}
public:
	QString src;
};

const QEvent::Type PipelineEvent::PrepareWindowId = static_cast<QEvent::Type>(QEvent::registerEventType());
const QEvent::Type PipelineEvent::StateChange = static_cast<QEvent::Type>(QEvent::registerEventType());
const QEvent::Type PipelineEvent::Qos = static_cast<QEvent::Type>(QEvent::registerEventType());
const QEvent::Type PipelineEvent::Error = static_cast<QEvent::Type>(QEvent::registerEventType());

class PrepareWindowIdEvent: public PipelineEvent {
public:
	PrepareWindowIdEvent(QString src, Overlay * overlay) :
			PipelineEvent(PrepareWindowId, src), overlay(overlay) {
	}
	virtual ~PrepareWindowIdEvent() {
	}
	Overlay * getOverlay() {
		return overlay;
	}
	static QEvent::Type type() {
		return PrepareWindowId;
	}
private:
	Overlay * overlay;
};

class StateChangedEvent: public PipelineEvent {
public:
//	enum State {
//		VoidPending, Null, Ready, Paused, Playing
//	};
	StateChangedEvent(QString src, Pipeline::State oldState, Pipeline::State newState, Pipeline::State pendingState) :
			PipelineEvent(StateChange, src), oldState(oldState), newState(newState), pendingState(pendingState) {
	}
	virtual ~StateChangedEvent() {
	}
	static QEvent::Type type() {
		return StateChange;
	}
	Pipeline::State getOldState() {
		return oldState;
	}
	Pipeline::State getNewState() {
		return newState;
	}
	Pipeline::State getPendingState() {
		return pendingState;
	}
private:
	Pipeline::State oldState;
	Pipeline::State newState;
	Pipeline::State pendingState;
};

class QosData {
public:
	// timestamps and live status
	// If the message was generated by a live element
	bool live;
	// running_time, stream_time, timestamp and duration of the dropped buffer.
	// Values of GST_CLOCK_TIME_NONE mean unknown values.
	quint64 running_time;
	quint64 stream_time;
	quint64 timestamp;
	quint64 duration;

	// values
	// The difference of the running-time against the deadline.
	qint64 jitter;
	// Long term prediction of the ideal rate relative to normal rate to get optimal quality.
	qreal proportion; // won't work on ARM?
	// An element dependent integer value that specifies the current quality level of the element.
	// The default maximum quality is 1000000.
	qint32 quality;

	// stats
	// QoS stats representing the history of the current continuous pipeline playback period.
	// When format is GST_FORMAT_UNDEFINED both dropped and processed are invalid.
	// Values of -1 for either processed or dropped mean unknown values.

	// Units of the 'processed' and 'dropped' fields.
	// Video sinks and video filters will use GST_FORMAT_BUFFERS (frames).
	// Audio sinks and audio filters will likely use GST_FORMAT_DEFAULT (samples)
	//GstFormat format;
	// Total number of units correctly processed since the last state change to READY or a flushing operation.
	quint64 processed;
	// Total number of units dropped since the last state change to READY or a flushing operation.
	quint64 dropped;

	QString timestamps() {
		return QString("live: %0\nrunning time: %1\nstream time: %2\ntimestamp: %3\nduration: %4").arg(live).arg(running_time).arg(stream_time).arg(timestamp).arg(duration);
	}
	QString values() {
		return QString("jitter: %0\nproportion: %1\nquality: %2").arg(jitter).arg(proportion).arg(quality);
	}
	QString stats() {
		return QString("format: %0\nprocessed: %1\ndropped: %2").arg("").arg(processed).arg(dropped);
	}
};

class QosEvent: public PipelineEvent {
public:
	QosEvent(QString src, QosData data) : PipelineEvent(Qos, src), data(data) {
	}
	virtual ~QosEvent()
	{
	}
	static QEvent::Type type() {
		return Qos;
	}
	QosData getData() {
		return data;
	}
private:
	QosData data;
};

class ErrorEvent: public PipelineEvent {
public:
	ErrorEvent(QString src, QString message, QString debug) : PipelineEvent(Error, src), message(message), debug(debug) {
	}
	virtual ~ErrorEvent()
	{
	}
	static QEvent::Type type() {
		return Error;
	}
	QString getMessage() {
		return message;
	}
	QString getDebug() {
		return debug;
	}
private:
	QString message;
	QString debug;
};

#endif /* PIPELINEEVENT_H_ */

